hash는 “**어떤 데이터를 고정 길이 숫자(또는 비트열)로 바꾸는 함수와 그 결과**”라고 생각하면 되고,
이걸 이용해서 **빠르게 찾기 / 중복 확인 / 무결성 확인** 같은 일을 아주 자주 합니다.

C 언어 기준으로, hash가 **주로 쓰이는 곳**을 나눠서 볼게요.

---

## 1. 해시 테이블(Hashtable) – 가장 대표적인 용도

**키(key) → 값(value)** 을 빠르게 찾을 때 씁니다.

* 예: 학생번호 → 학생 구조체 포인터
* 예: 문자열 이름 → 전화번호

특징:

* 평균적으로 `O(1)` 시간에 탐색/삽입/삭제 가능 (배열처럼 빠른 느낌)
* 배열 인덱스 대신,
  `index = hash(key) % table_size;`
  이런 식으로 **해시값으로 배열 인덱스를 계산**해서 접근

C에서 흔한 사용처:

* 직접 구현하는 **연관 배열(associative array)**
* 라이브러리(Glib의 `GHashTable` 등)의 내부 구조
* 운영체제/커널 내 각종 **ID → 구조체 포인터 매핑**(파일 디스크립터, 소켓 등)

---

## 2. Set(집합) 구현 – “이미 있는 값인지” 빨리 확인

어떤 값이 **이미 나왔는지** 빠르게 체크하고 싶을 때 hash를 많이 씁니다.

* 예: 중복 이메일 체크
* 예: 이미 방문한 노드/상태인지 확인 (그래프 탐색, 검색 알고리즘 등)

C에서는:

* `int`, `char*` 등을 키로 하는 **Hash Set**을 구현해서
  `insert(x)` 하기 전에 `contains(x)`로 **중복 검사**하는 식으로 사용
* 배열/리스트로 검사하면 `O(n)`인데, Hash Set을 쓰면 평균 `O(1)`에 가능

---

## 3. 컴파일러, 인터프리터의 “심볼 테이블(Symbol Table)”

C 컴파일러도 내부에서 해시를 엄청 씁니다.

* **변수 이름 → 정보(타입, 스코프, 메모리 위치 등)**
* **함수 이름 → 함수 정보**

이런 매핑을 관리하는 테이블이 거의 다 **해시 테이블**입니다.

여기서 hash가 없으면, 매번 문자열 비교를 길게 해야 해서 성능이 크게 나빠집니다.

---

## 4. 캐시(Cache) – 최근 사용 결과 빠르게 다시 쓰기

어떤 계산 결과나 I/O 결과를 **캐싱**할 때도 hash를 많이 씁니다.

* 예:

  * 웹 서버: URL → 응답 페이지 캐시
  * DB 클라이언트: 쿼리 문자열 → 결과 캐시
  * 이미지 변환 결과 캐시 등

핵심 아이디어:

* “**같은 입력**이면 **같은 해시값**이 나오니까,
  hash를 키로 해서 결과를 빠르게 찾아 쓰자.”

C 프로그램에서도:

* 딥러닝 inference 결과,
* 비싼 수학 계산 결과,
* 파일 파싱 결과 등을 해시 기반 캐시로 저장해두고 재사용할 수 있습니다.

---

## 5. 패스워드 저장, 인증 – (주의: 여기서는 **암호학적 해시**)

보안 쪽에서는 **암호학적 해시 함수**(SHA-256 등)를 써서:

1. **비밀번호를 그대로 저장하지 않고 hash만 저장**

   * 로그인할 때 입력 비밀번호를 다시 hash해서 비교
2. 메시지가 중간에 바뀌었는지 확인 (무결성, integrity 확인)

C에서는 OpenSSL, libsodium 같은 라이브러리를 써서:

```c
// Pseudo 예시: 비밀번호 string → SHA-256 해시
unsigned char hash[32];
SHA256((unsigned char*)password, strlen(password), hash);
```

이런 식으로 사용합니다.

---

## 6. 데이터 무결성 체크 – 파일이 손상/변경되었는지 검사

다운로드한 파일이 원본과 같은지 확인할 때:

* `파일 전체 데이터 → 해시값` 계산
* 공식적으로 제공된 해시값과 비교해서 일치하면 OK

실제 예:

* `md5sum`, `sha256sum` 같은 리눅스 명령
* 백업 프로그램, 패치 프로그램, 버전 관리 시스템 등

C 프로그램에서는:

* 큰 파일을 읽으면서 조금씩 hash 업데이트 → 최종 해시값 비교
* 네트워크 전송 시, 데이터 + 체크섬(해시값) 같이 보내고 수신 측에서 검증

---

## 7. 네트워크, OS, 데이터베이스 내부 구조

실제 시스템 레벨에서도 hash는 엄청 많이 나옵니다.

* **네트워크**

  * 라우터/스위치의 MAC 주소 테이블
  * 연결 정보 (IP, Port) → 소켓 구조체
* **운영체제(OS)**

  * 파일 핸들, 프로세스 ID, thread ID, descriptor 등 관리할 때
* **데이터베이스**

  * 해시 인덱스(Hash index) 구조
    (B-Tree 인덱스와 함께 가장 대표적인 인덱스 방식)

C로 직접 구현하는 경우보다는,
“**C로 작성된 시스템 내부에서 해시 테이블이 핵심 자료구조로 쓰인다**”고 보는 게 맞습니다.

---

## 8. 간단한 C 코드 관점에서 요약

C 언어 수업/실습에서 해시를 쓰는 가장 흔한 패턴은:

1. **해시 함수 설계**

   * 정수 키: `hash = key % table_size;`
   * 문자열 키:

     ```c
     unsigned long hash(const char *s) {
         unsigned long h = 5381;
         int c;
         while ((c = *s++))
             h = ((h << 5) + h) + c; // h*33 + c, djb2
         return h;
     }
     ```
2. 해시값을 **배열 인덱스**로 사용해서

   * key/value를 저장 (해시 테이블)
   * 존재 여부 확인 (Set)
3. 충돌 처리 (체이닝, 오픈 어드레싱 등)를 추가

---

## 정리 한 줄 버전

* **hash = 데이터를 고정 길이 값으로 바꾸는 함수**
* **C에서 hash는 주로**

  1. 해시 테이블 / 연관 배열 (빠른 검색)
  2. Set 구현 (중복 / 존재 여부 확인)
  3. 컴파일러의 심볼 테이블
  4. 각종 캐시 구조
  5. 암호/인증(패스워드 저장, 메시지 무결성)
  6. 파일/데이터 무결성 체크
  7. OS, 네트워크, DB 등 시스템 내부 인덱싱

---

다음 단계로 해보고 싶다면:

1. `int` 키용 간단한 해시 테이블 구현
2. `char*`(문자열) 키용 해시 테이블 구현
3. 그걸로 **심볼 테이블 흉내내기**

   * 변수 이름 → int 값 저장/검색

원하시면, ① int 버전, ② 문자열 버전 중 하나 골라서
**완전한 C 예제 코드**(삽입/검색/삭제 포함)도 같이 만들어 드릴게요.

맞습니다\! 질문하신 대로 **`main` 함수 안에서만** 코드를 짠다면 이중 포인터는 전혀 필요 없습니다.

```c
int main() {
    int num = 100;
    int* p = NULL;

    p = &num;       // 그냥 이렇게 하면 됩니다. (이중 포인터 필요 X)
    printf("%d", *p); 
    return 0;
}
```

하지만, 우리가 **"함수(Function)"** 로 이 작업을 분리하려고 할 때 문제가 발생합니다.
C언어의 **"모든 것은 복사해서 넘어간다(Call by Value)"** 는 특성 때문입니다.

이 차이를 명확하게 보여드릴게요.

-----

### 1\. 실패하는 상황 (싱글 포인터 `*` 사용 시)

친구(함수)에게 "내 나침반(`p`)의 방향 좀 바꿔줘"라고 부탁하는 상황입니다.

```c
#include <stdio.h>

void changePointer(int* ptr, int* target) {
    // 여기서 ptr은 main의 p가 아닙니다. 
    // p를 복사해 온 '복사본'입니다.
    
    ptr = target; // 복사본의 방향만 바꿨습니다.
    
    printf("함수 안: %d 가리킴\n", *ptr); // 여기선 바뀐 것처럼 보임 (100)
}

int main() {
    int num = 100;
    int* p = NULL;

    // p의 값(NULL)을 복사해서 보냄
    changePointer(p, &num);

    // 함수가 끝나고 돌아왔는데...
    // 원본 p는 여전히 NULL입니다. (변하지 않음!)
    if (p == NULL) {
        printf("메인 함수: p는 여전히 NULL입니다.\n");
    }

    return 0;
}
```

**비유하자면:**

1.  선생님(`main`)이 칠판(`p`)에 내용을 적어야 합니다.
2.  학생(`changePointer`)에게 칠판을 가져오라고 시키는 대신, **칠판 사진을 찍어서(복사)** 보냈습니다.
3.  학생이 그 **사진 위에 낙서(`ptr = target`)** 를 했습니다.
4.  교실에 있는 **진짜 칠판(`p`)** 에는 아무런 변화가 없습니다.

-----

### 2\. 성공하는 상황 (이중 포인터 `**` 사용 시)

이제 학생에게 사진을 보내는 게 아니라, **"칠판이 어디에 있는지 위치(`&p`)"** 를 알려주는 것입니다.

```c
#include <stdio.h>

// int** pp : "포인터가 있는 주소"를 받겠다
void changePointerReal(int** pp, int* target) {
    // *pp : 주소를 따라가니 진짜 p가 있네?
    // 진짜 p의 값을 변경!
    *pp = target; 
}

int main() {
    int num = 100;
    int* p = NULL;

    // p의 '주소(&p)'를 보냄 (칠판 위치를 알려줌)
    changePointerReal(&p, &num);

    printf("메인 함수: %d\n", *p); // 100 (성공!)

    return 0;
}
```

**비유하자면:**

1.  선생님(`main`)이 학생(`changePointerReal`)에게 말합니다.
2.  "내 칠판(`p`)은 **1분단 맨 앞자리(`&p`)** 에 있어. 가서 고쳐놔."
3.  학생이 그 자리로 찾아가서 **진짜 칠판(`*pp`)** 의 내용을 바꿉니다.
4.  나중에 보니 진짜 칠판이 바뀌어 있습니다.

### 결론

1.  **`main` 안에서 혼자 할 때:** `p = &num` 하면 됩니다. (`**` 필요 없음)
2.  **함수에게 시킬 때:**
      * 변수의 **값(데이터)** 을 바꾸고 싶으면 -\> 주소(`*`)를 보낸다.
      * 변수가 **포인터**인데, 그 **포인터의 방향(주소)** 자체를 바꾸고 싶으면 -\> 포인터의 주소(`**`)를 보낸다.

아까 트리 예제에서 `insert` 함수는 **"빈자리(`NULL`)"를 "새 노드"로 바꿔야 하는 임무**가 있었기 때문에, `root` 포인터 자체를 바꾸기 위해 이중 포인터를 쓴 것입니다.

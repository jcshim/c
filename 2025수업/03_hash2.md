좋은 질문이에요.
**“해시 쓸 바에야 그냥 배열 쓰면 더 빠른 거 아니야?”** → 경우에 따라 **맞기도 하고, 틀리기도** 합니다.

정리하면:

> 🔹 **키가 작고(예: 0~100), 연속적이고, 범위를 미리 안다면 → 배열이 최강**
> 🔹 **키가 크거나, 듬성듬성이고, 문자열 같은 걸 키로 쓰고 싶다면 → 해시가 필요**

---

## 1. 사실 해시 테이블 안에도 “배열”이 들어있다

지금 만든 해시 테이블도 내부 구조는 그냥 **배열**입니다.

```c
int table[TABLE_SIZE];
```

* 해시 함수: `hash(key)`
* 결국 **배열의 인덱스** 하나를 골라서 `table[index]`에 저장하는 거죠.

즉,

> 해시 테이블 = “배열 + (키 → 인덱스 바꾸는 해시 함수) + 충돌 처리 로직”

그래서 **“배열 vs 해시”**라기보다는
**“그냥 키를 인덱스로 쓰는 배열 vs 해시로 인덱스를 계산해서 쓰는 배열”**의 차이입니다.

---

## 2. 배열이 더 효율적인 “이상적인 경우”

예를 들어, 키가 항상 **0 ~ 9** 사이 정수라고 합시다.
그러면 굳이 해시 같은 거 안 쓰고 이렇게 하면 됩니다:

```c
#include <stdio.h>

#define MAX_KEY 10

int exist[MAX_KEY];  // 0이면 없음, 1이면 있음

void insert(int key) {
    exist[key] = 1;
}

int find(int key) {
    return exist[key];
}

int main(void) {
    int data[] = {1, 3, 5, 7, 9};
    int n = (int)(sizeof(data) / sizeof(data[0]));

    for (int i = 0; i < n; i++) {
        insert(data[i]);
    }

    for (int k = 0; k < MAX_KEY; k++) {
        if (find(k))
            printf("%d exists\n", k);
    }
}
```

* 삽입: `exist[key] = 1;` → O(1)
* 검색: `exist[key];` → O(1)
* **해시 계산도 없고, 충돌도 없음** → 이게 진짜 제일 빠른 방식입니다.

👉 **이런 상황에서는 “해시보다 그냥 배열이 더 빠르고 단순하다”가 100% 맞는 말입니다.**

---

## 3. 그런데 왜 굳이 해시를 쓰냐?

문제는 **현실의 키들이 이렇게 착하지 않다는 것**입니다.

예를 들어:

* 키가 **0 ~ 1,000,000** 사이 정수일 수 있다
* 근데 실제로 저장하는 원소는 **100개만** 있다

이때 두 가지 선택지가 있어요.

### (1) 배열만 쓰는 경우

```c
int exist[1000001];  // 0 ~ 1000000
```

* 메모리: `1000001 * sizeof(int)` → 대략 4MB
  (더 큰 범위면 수십~수백 MB, 수 GB도 가능)
* 실제로는 100개만 쓰는데 **나머지는 전부 낭비**

### (2) 해시 테이블 사용하는 경우

```c
#define TABLE_SIZE 211   // 100개 정도 담을 해시 테이블
int table[TABLE_SIZE];
```

* 메모리: 211 * sizeof(int) → 844바이트 정도
* 키가 10이든, 999999든, 123456789든
  → `hash(key)`만 잘 만들면 **작은 배열 안에 다 담을 수 있음**

즉,

> 🔹 키의 범위가 **엄청 넓고**,
> 🔹 실제로 사용하는 키는 **몇 개 안 될 때**,
> → 배열은 메모리를 너무 많이 쓰기 때문에 **비효율**
> → 그래서 **작은 배열 + 해시 함수**라는 꼼수를 쓰는 것 = 해시 테이블

---

## 4. 지금 예제 코드 기준으로 비교해 보면

지금 코드에서 사용하는 키는 `{15, 25, 35, 5, 7, 17}` 입니다.

* 만약 **키가 항상 0~99 사이**라면:

  * 그냥 `int exist[100];` 만들어서 `exist[key] = key;` 하면 끝입니다.
  * 이 경우엔 **해시보다 배열이 더 단순하고 효율적**입니다.

* 그런데 “언제든지 사용자 입력으로 아무 정수든 들어올 수 있다”고 가정하면?

  * `exist[1000000000];` 같은 배열은 만들 수가 없죠 😅
  * **키의 범위를 모를 때**, **너무 클 때** → 해시의 장점이 살아납니다.

즉, **교수님(?)이 일부러 예제에서 TABLE_SIZE를 10으로 둔 이유**는:

> “키(정수)가 커지거나 범위를 모를 때도,
> 작은 배열 하나로 잘 찾아보자” → 이게 해시 테이블의 존재 이유라서 그래요.

---

## 5. 시간 복잡도 관점으로 한 번 더 정리

### 1) 배열 (direct addressing)

* 조건: `0 <= key <= MAX_KEY` 이고, MAX_KEY가 너무 크지 않다.
* 삽입: `O(1)`
* 검색: `O(1)`
* 메모리: `O(MAX_KEY)`

### 2) 정렬된 배열 + 이진 탐색

* 삽입: O(n) (밀어넣기)
* 검색: O(log n)
* 메모리: O(n)

### 3) 해시 테이블

* 평균 삽입/검색: **O(1)**  (충돌이 적고, 테이블이 너무 안 꽉 찼을 때)
* 최악: O(n) (해시 함수가 안 좋거나, 너무 꽉 찄을 때)
* 메모리: O(n) 정도 (테이블 크기 ≈ 원소 개수의 몇 배)

**키의 크기/범위를 생각하면:**

* 배열 direct addressing: **키의 값에 비례해서 메모리가 필요**
* 해시 테이블: **요소 개수에 비례해서 메모리가 필요**

---

## 6. 결론 정리

> **Q. 해시를 사용하는 것 보다 배열을 사용하는 것이 더 효율이 높지 않을까?**

* **키가 작고, 범위가 좁고, 연속적이고, 미리 알 수 있다면 → YES, 배열이 최고입니다.**
* 하지만 실제 문제에서는

  * 키가 **너무 크거나**
  * **문자열이거나** (예: "user123", "hello", "abc")
  * 범위를 미리 모를 때가 많아서
  * **작은 배열 하나로 많은 키를 다루기 위해** 해시 테이블을 씁니다.

그래서 자료구조를 가르칠 때는,

1. 배열 / 선형 탐색
2. 정렬 + 이진 탐색
3. 트리
4. **해시 테이블**

이렇게 **검색 방법의 발전 과정** 속에서 해시를 소개하는 거죠.

---

원하시면 다음으로:

* **“학번(예: 20230001 같은 큰 정수)을 키로 쓰는 경우”**

  * 배열 vs 해시 메모리·코드 차이
* 또는 **문자열 키("kim", "lee")를 해시로 처리하는 코드 예시**

이런 쪽으로도 바로 예제 코드를 보여드릴게요.
